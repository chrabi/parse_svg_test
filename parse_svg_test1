import os
import re
from xml.etree import ElementTree as ET

def extract_x_y_from_transform(transform_value):
    match = re.search(r'matrix\(([^)]+)\)', transform_value)
    if match:
        values = match.group(1).split()
        if len(values) == 6:
            return float(values[4]), float(values[5])
    return None, None

def create_new_transform(original_transform, new_x):
    match = re.search(r'matrix\(([^)]+)\)', original_transform)
    if match:
        values = match.group(1).split()
        if len(values) == 6:
            values[4] = str(new_x)
            return f"matrix({' '.join(values)})"
    return original_transform

def find_parent(root, element):
    for parent in root.iter():
        for child in parent:
            if child == element:
                return parent
    return None

def calculate_average_step(elements):
    if len(elements) < 2:
        return 7.8  # Domyślna wartość, jeśli nie ma wystarczającej liczby elementów

    x_values = [x for _, (x, _, _) in elements]
    if len(x_values) < 2:
        return 7.8  # Domyślna wartość, jeśli nie można obliczyć odstępu

    differences = [x_values[i+1] - x_values[i] for i in range(len(x_values)-1)]
    return sum(differences) / len(differences)

def create_square_path(x, y, size):
    return f"M {x} {y} h {size} v {size} h -{size} Z"

def generate_location_id(x, y):
    col = chr(65 + (x // 26)) + chr(65 + (x % 26))
    row = f"{y:03d}"
    return f"{col}{row}"

def clean_and_update_svg(file_path):
    ET.register_namespace("", "http://www.w3.org/2000/svg")
    tree = ET.parse(file_path)
    root = tree.getroot()

    # Usuń sekcję <g clip-path="url(#clip6)">
    for element in root.findall(".//*[@clip-path='url(#clip6)']"):
        parent = find_parent(root, element)
        if parent is not None:
            parent.remove(element)

    text_elements = root.findall(".//*{http://www.w3.org/2000/svg}text")

    elements_dict = {}
    for element in text_elements:
        if element.text and element.text.isdigit() and len(element.text) == 3:
            value = int(element.text)
            transform = element.get('transform')
            if transform:
                x, y = extract_x_y_from_transform(transform)
                if x is not None and y is not None:
                    elements_dict[value] = (x, y, element)

    if not elements_dict:
        print(f"Nie znaleziono elementów numerycznych w pliku: {file_path}")
        return

    # Sortuj elementy według ich wartości numerycznej
    sorted_elements = sorted(elements_dict.items())

    # Wybierz element startowy (z najmniejszą wartością)
    start_value, (start_x, start_y, start_element) = sorted_elements[0]

    # Oblicz średni odstęp między elementami
    average_step = calculate_average_step(sorted_elements[:4])  # Użyj pierwszych 4 elementów do obliczenia odstępu

    # Uzupełnij brakujące wartości
    for i in range(start_value, 132):  # Uzupełniamy do 131
        if i not in elements_dict:
            new_x = start_x + (i - start_value) * average_step
            new_y = start_y
            new_element = ET.Element('{http://www.w3.org/2000/svg}text')
            new_element.text = f"{i:03d}"
            new_transform = create_new_transform(start_element.get('transform'), new_x)
            new_element.set('transform', new_transform)
            elements_dict[i] = (new_x, new_y, new_element)
            parent = find_parent(root, start_element)
            if parent is not None:
                parent.append(new_element)

    # Utwórz grupę dla kwadratów
    squares_group = ET.SubElement(root, 'g', {'id': 'squares'})

    # Dodaj kwadraty dla istniejących lokalizacji
    square_size = average_step * 0.8  # Rozmiar kwadratu nieco mniejszy niż odstęp
    for y in range(1, 132):
        for x in range(21):  # 03A to 03U to 21 kolumn
            location_id = generate_location_id(x, y)
            square_x = start_x + x * average_step
            square_y = start_y + (y - 1) * average_step
            try:
                square_path = create_square_path(square_x, square_y, square_size)
                ET.SubElement(squares_group, 'path', {
                    'd': square_path,
                    'id': location_id,
                    'fill': 'rgba(0, 255, 0, 0.5)',  # Półprzezroczysty zielony
                    'stroke': 'black',
                    'stroke-width': '0.5'
                })
            except Exception as e:
                print(f"Błąd przy tworzeniu kwadratu dla lokalizacji {location_id}: {e}")

    tree.write(file_path, encoding='utf-8', xml_declaration=True)

def main():
    svg_directory = '.'

    for filename in os.listdir(svg_directory):
        if filename.endswith('.svg'):
            file_path = os.path.join(svg_directory, filename)
            clean_and_update_svg(file_path)
            print(f"Zaktualizowano i wyczyszczono plik: {filename}")

if __name__ == "__main__":
    main()
