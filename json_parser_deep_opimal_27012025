import json
import csv
import ijson
import logging
from typing import Dict, Any
from multiprocessing import Pool
import time
import sys
from logging import handlers

# Konfiguracja logowania z obsługą UTF-8
class SafeLogging:
    @staticmethod
    def configure():
        log_format = '%(asctime)s - %(levelname)s - %(message)s'
        log_handlers = [
            handlers.RotatingFileHandler(
                'processing.log', 
                encoding='utf-8',
                maxBytes=10*1024*1024,
                backupCount=5
            ),
            logging.StreamHandler(
                stream=open(sys.stdout.fileno(), 
                          'w', 
                          encoding='utf-8',
                          errors='replace',
                          closefd=False)
            )
        ]
        
        logging.basicConfig(
            level=logging.INFO,
            format=log_format,
            handlers=log_handlers
        )

# Wywołaj konfigurację przed głównym kodem
SafeLogging.configure()
logger = logging.getLogger(__name__)

# # Konfiguracja logowania
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s - %(levelname)s - %(message)s',
#     handlers=[
#         logging.FileHandler('processing.log'),
#         logging.StreamHandler()
#     ]
# )
# logger = logging.getLogger(__name__)

# Konfiguracja
INPUT_FILE = 'text.json'
BATCH_SIZE = 1000
FILE_SPECS = {
    'Inventory_base': ['OmeId', 'DeviceId', 'SourceLoadTimeEpoch', 'SerialNumber', 'Model', 'Name'],
    'Uptime': ['OmeId', 'DeviceId', 'SourceLoadTimeEpoch', 'SerialNumber', 'systemUptime'],
    'Temperature': ['OmeId', 'DeviceId', 'SourceLoadTimeEpoch', 'SerialNumber', 
                   'peakTemperature', 'avgTemperature', 'startTime', 'peakTemperatureTimeStamp'],
    'InventoryDetailsDisk': ['OmeId', 'DeviceId', 'SourceLoadTimeEpoch', 'SerialNumber',
                            'Id', 'DiskNumber', 'ModelNumber', 'PartNumber', 'Size',
                            'UsedSpace', 'EncryptionAbility', 'RaidStatus', 'SecurityState', 'Status']
}

class CSVWriter:
    def __init__(self):
        self.writers = {}
        self.files = {}
        
    def __enter__(self):
        for category in FILE_SPECS:
            file = open(f'{category}.csv', 'w', newline='', encoding='utf-8')
            writer = csv.DictWriter(file, fieldnames=FILE_SPECS[category])
            writer.writeheader()
            self.writers[category] = writer
            self.files[category] = file
        return self
    
    def write_row(self, category: str, row: Dict[str, Any]):
        try:
            self.writers[category].writerow(row)
        except Exception as e:
            logger.error(f"Error zapisu wiersza: {e} | Kategoria: {category} | Wiersz: {row}")

    def __exit__(self, exc_type, exc_val, exc_tb):
        for file in self.files.values():
            file.close()

def process_item(item: Dict[str, Any]) -> Dict[str, list]:
    result = {category: [] for category in FILE_SPECS}
    
    try:
        # Inventory Base
        result['Inventory_base'].append({
            'OmeId': item.get('OmeId', ''),
            'DeviceId': item.get('DeviceId', ''),
            'SourceLoadTimeEpoch': item.get('TimeEpoch', ''),
            'SerialNumber': item.get('SerialNumber', ''),
            'Model': item.get('Model', ''),
            'Name': item.get('Name', '')
        })

        # Uptime
        uptime_data = item.get('Uptime_data', {}) or {}
        result['Uptime'].append({
            'OmeId': item.get('OmeId', ''),
            'DeviceId': item.get('DeviceId', ''),
            'SourceLoadTimeEpoch': item.get('TimeEpoch', ''),
            'SerialNumber': item.get('SerialNumber', ''),
            'systemUptime': uptime_data.get('systemUptime', '') if isinstance(uptime_data, dict) else ''
        })

        # Temperature
        temp_data = item.get('Temperature_data', {}) or {}
        result['Temperature'].append({
            'OmeId': item.get('OmeId', ''),
            'DeviceId': item.get('DeviceId', ''),
            'SourceLoadTimeEpoch': item.get('TimeEpoch', ''),
            'SerialNumber': item.get('SerialNumber', ''),
            'peakTemperature': temp_data.get('peakTemperature', ''),
            'avgTemperature': temp_data.get('avgTemperature', ''),
            'startTime': temp_data.get('startTime', ''),
            'peakTemperatureTimeStamp': temp_data.get('peakTemperatureTimeStamp', '')
        })

        # Inventory Details Disk
        disk_data = item.get('InventoryDetailsDisk_data', {}) or {}
        for disk in disk_data.get('InventoryInfo', []) if isinstance(disk_data, dict) else []:
            result['InventoryDetailsDisk'].append({
                'OmeId': item.get('OmeId', ''),
                'DeviceId': item.get('DeviceId', ''),
                'SourceLoadTimeEpoch': item.get('TimeEpoch', ''),
                'SerialNumber': item.get('SerialNumber', ''),
                'Id': disk.get('Id', ''),
                'DiskNumber': disk.get('DiskNumber', ''),
                'ModelNumber': disk.get('ModelNumber', ''),
                'PartNumber': disk.get('PartNumber', ''),
                'Size': disk.get('Size', ''),
                'UsedSpace': disk.get('UsedSpace', ''),
                'EncryptionAbility': disk.get('EncryptionAbility', ''),
                'RaidStatus': disk.get('RaidStatus', ''),
                'SecurityState': disk.get('SecurityState', ''),
                'Status': disk.get('Status', '')
            })
            
    except Exception as e:
        logger.error(f"Blad przetwarzania rekordu: {e} | Item: {item}")
        
    return result

def main():
    start_time = time.time()
    
    try:
        with CSVWriter() as writer, open(INPUT_FILE, 'r', encoding='utf-8') as f:
            items = ijson.items(f, 'item')
            batch = []
            
            for idx, item in enumerate(items, 1):
                batch.append(item)
                
                if idx % BATCH_SIZE == 0:
                    with Pool() as pool:
                        results = pool.map(process_item, batch)
                        
                    for result in results:
                        for category in FILE_SPECS:
                            for row in result[category]:
                                writer.write_row(category, row)
                    
                    batch = []
                    logger.info(f"Przetworzono lacznie {idx} rekordow | Calkowity czas: {time.time()-start_time:.2f}s")
            
            # Ostatnia partia
            if batch:
                with Pool() as pool:
                    results = pool.map(process_item, batch)
                
                for result in results:
                    for category in FILE_SPECS:
                        for row in result[category]:
                            writer.write_row(category, row)
                
                logger.info(f"Przetworzono lacznie {idx} rekordow | Calkowity czas: {time.time()-start_time:.2f}s")
                
    except Exception as e:
        logger.critical(f"Krytyczny blad: {str(e)}", exc_info=True)
        raise

if __name__ == "__main__":
    main()
